from typing import Callable, List, Optional, Dict, Any

from core.config import AppConfig
from core.storage import ClipboardStorage
from core.repository import ClipRepository
from core.app_state import AppState
from core.retention import enforce_max_items
from core.clipboard_writer import copy_entry
from core.backup import export_to_json_str, import_from_json_str


class AppEngine:
    """
    High-level orchestration:
    - Manages storage/repository lifecycle
    - Handles foreground ingestion with last-seen guard
    - Optional background monitoring
    - Retention enforcement after ingestion
    """

    def __init__(self, config: AppConfig, clock: Optional[Callable[[], float]] = None) -> None:
        self.config = config
        self.storage = ClipboardStorage(config.storage_path)
        self.repo = ClipRepository(self.storage, clock=clock)
        self.state = AppState(self.repo, config)
        self._monitor = None  # type: ignore

    def on_foreground(self, reader: Optional[Callable[[], Optional[str]]] = None) -> Optional[Dict[str, Any]]:
        row = self.state.on_foreground(reader=reader)
        if row is not None:
            try:
                enforce_max_items(self.storage, self.config.max_items, include_pinned_in_limit=False)
            except Exception:
                # retention is best-effort
                pass
        return row

    def start_monitor(self, reader: Callable[[], Optional[str]], interval: Optional[float] = None) -> bool:
        """
        Start background clipboard monitor. Returns False if already running.
        """
        try:
            from core.monitor import ClipboardMonitor  # local import to avoid cycles
        except Exception:
            return False
        if self._monitor is not None and getattr(self._monitor, "is_running", lambda: False)():
            return False
        mon = ClipboardMonitor(
            repo=self.repo,
            reader=reader,
            interval=float(interval if interval is not None else 1.0),
            case_insensitive=self.config.dedupe_case_insensitive,
        )
        ok = mon.start()
        self._monitor = mon
        return ok

    def stop_monitor(self) -> None:
        mon = self._monitor
        if mon is not None:
            try:
                mon.stop()
            except Exception:
                pass
        self._monitor = None

    def is_monitor_running(self) -> bool:
        mon = self._monitor
        return bool(mon and mon.is_running())

    # Convenience wrappers
    def list_all(self, limit: Optional[int] = None) -> List[Dict[str, Any]]:
        return self.repo.list_all(limit=limit)

    def search(self, query: str, limit: Optional[int] = None) -> List[Dict[str, Any]]:
        return self.repo.search(query, limit=limit)

    def pin(self, clip_id: int, pinned: bool = True) -> bool:
        return self.repo.pin(clip_id, pinned)

    def delete(self, clip_id: int) -> bool:
        return self.repo.delete(clip_id)

    def copy(self, clip_id: int, writer: Optional[Callable[[str], bool]] = None,
             time_provider: Optional[Callable[[], float]] = None) -> bool:
        return copy_entry(self.repo, clip_id, set_text=writer, time_provider=time_provider)

    def export_json(self, indent: Optional[int] = 2) -> str:
        return export_to_json_str(self.storage, indent=indent)

    def import_json(self, content: str) -> int:
        changed = import_from_json_str(self.storage, content)
        # enforce retention after import
        try:
            enforce_max_items(self.storage, self.config.max_items, include_pinned_in_limit=False)
        except Exception:
            pass
        return changed

    def close(self) -> None:
        self.stop_monitor()
        try:
            self.storage.close()
        except Exception:
            pass