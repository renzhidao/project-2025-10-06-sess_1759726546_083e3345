from typing import List, Optional

from core.history import History, ClipEntry
from core.repository import ClipRepository


class HistoryStorageSync:
    """
    Utilities to synchronize in-memory History with persistent storage via ClipRepository.
    - load_from_storage: populate History from repository list, preserving order and pinned flags.
    - flush_to_storage: persist History items into repository, preserving pinned flags and relative recency.
    """

    def __init__(self, history: History, repo: ClipRepository) -> None:
        self.history = history
        self.repo = repo

    def _clear_history(self) -> None:
        # Clear safely using public API
        for e in list(self.history.list()):
            self.history.remove(e.id)

    def load_from_storage(self, clear_history: bool = False) -> int:
        """
        Load items from repository into history.
        - If clear_history is True, empties current history first.
        - Order preservation: within pinned/unpinned groups, newer items should surface first.
          We insert items oldest->newest, so History's timestamps reflect the expected order.
        Returns number of items loaded.
        """
        if clear_history:
            self._clear_history()

        rows = self.repo.list_all()
        pinned_rows = [r for r in rows if r["pinned"]]
        unpinned_rows = [r for r in rows if not r["pinned"]]

        # Insert oldest -> newest to ensure recency ordering in History
        def sort_key(r):
            return (int(r["created_at"]), int(r["id"]))

        for r in sorted(pinned_rows, key=sort_key):
            e = self.history.add(r["text"])
            self.history.pin(e.id, True)

        for r in sorted(unpinned_rows, key=sort_key):
            self.history.add(r["text"])

        return len(rows)

    def flush_to_storage(
        self,
        include_pinned: bool = True,
        include_unpinned: bool = True,
    ) -> int:
        """
        Persist History items into repository.
        - Adds or touches existing rows (NOCASE) via repo.add_text.
        - Ensures pinned flags in storage match History.
        - Inserts in ascending created_at order to preserve relative recency using repo clock.
        Returns number of history items processed (added/touched).
        """
        entries: List[ClipEntry] = self.history.list()

        filtered: List[ClipEntry] = []
        for e in entries:
            if e.pinned and include_pinned:
                filtered.append(e)
            elif (not e.pinned) and include_unpinned:
                filtered.append(e)

        # Oldest -> newest so repository timestamps reflect natural order
        filtered.sort(key=lambda e: (int(e.created_at), int(e.id)))

        processed = 0
        for e in filtered:
            row = self.repo.add_text(e.text, pinned=True if e.pinned else None)
            if e.pinned and not bool(row["pinned"]):
                # Ensure pinned state is propagated for existing duplicates
                self.repo.pin(int(row["id"]), True)
            processed += 1

        return processed