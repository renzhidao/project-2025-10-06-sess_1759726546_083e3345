import time
from typing import Callable, Dict, List, Optional

from core.storage import ClipboardStorage


class ClipRepository:
    """
    High-level repository that provides deduplicated add and management
    on top of ClipboardStorage.
    - add_text: if text exists (NOCASE), update its created_at (touch) and keep id/pinned.
                else insert new entry.
    - dedupe: delete duplicates, keep newest (by created_at, then id). If any duplicate
              was pinned, ensure the kept one is pinned.
    """

    def __init__(self, storage: ClipboardStorage, clock: Optional[Callable[[], float]] = None) -> None:
        self.storage = storage
        self._clock: Callable[[], float] = clock or time.time

    def _now(self) -> int:
        return int(self._clock())

    def add_text(self, text: str, pinned: Optional[bool] = None) -> Dict[str, object]:
        """
        Add or touch an existing text.
        - On new insert: pinned defaults to False unless explicitly True.
        - On duplicate: pinned state is preserved (pinned argument ignored).
        Returns the up-to-date row dict.
        """
        if not isinstance(text, str):
            raise TypeError("text must be a string")
        if text == "":
            raise ValueError("text must be non-empty")

        existing = self.storage.get_by_text(text)
        now = self._now()
        if existing:
            # Touch existing (keep id/pinned)
            self.storage.update_created_at(existing["id"], created_at=now)
            return self.storage.get_by_id(existing["id"])  # type: ignore[return-value]
        else:
            new_id = self.storage.insert_text(text, created_at=now, pinned=bool(pinned))
            return self.storage.get_by_id(new_id)  # type: ignore[return-value]

    def list_all(self, limit: Optional[int] = None) -> List[Dict[str, object]]:
        return self.storage.list_all(limit=limit)

    def search(self, query: str, limit: Optional[int] = None) -> List[Dict[str, object]]:
        return self.storage.search(query, limit=limit)

    def pin(self, clip_id: int, pinned: bool = True) -> bool:
        return self.storage.set_pinned(clip_id, pinned)

    def delete(self, clip_id: int) -> bool:
        return self.storage.delete(clip_id)

    def get_by_id(self, clip_id: int) -> Optional[Dict[str, object]]:
        return self.storage.get_by_id(clip_id)

    def dedupe(self) -> int:
        """
        Remove duplicates by text (case-insensitive).
        Keeps the newest by (created_at desc, id desc).
        If any duplicate of a key is pinned, the kept one becomes pinned.
        Returns the number of rows deleted.
        """
        rows = self.storage.list_all()
        # Sort by created_at desc, id desc (ignore pinned in ordering for dedupe)
        rows_sorted = sorted(rows, key=lambda r: (-int(r["created_at"]), -int(r["id"])))
        keep_by_key: Dict[str, Dict[str, object]] = {}
        pinned_any: Dict[str, bool] = {}
        to_delete: List[int] = []

        for r in rows_sorted:
            key = str(r["text"]).casefold()
            if key not in keep_by_key:
                keep_by_key[key] = r
                pinned_any[key] = bool(r["pinned"])
            else:
                to_delete.append(int(r["id"]))
                if bool(r["pinned"]):
                    pinned_any[key] = True

        # Ensure kept row pinned state if any duplicate was pinned
        for key, keep_row in keep_by_key.items():
            if pinned_any.get(key, False) and not bool(keep_row["pinned"]):
                self.storage.set_pinned(int(keep_row["id"]), True)

        deleted = 0
        for clip_id in to_delete:
            if self.storage.delete(clip_id):
                deleted += 1
        return deleted