import threading
from typing import Callable, Optional

from core.repository import ClipRepository


class ClipboardMonitor:
    """
    Polls the clipboard via a reader() function at a fixed interval and ingests
    new values into the repository. Avoids re-processing the same consecutive value
    by comparing a normalized key (case-insensitive by default).
    """

    def __init__(
        self,
        repo: ClipRepository,
        reader: Callable[[], Optional[str]],
        interval: float = 1.0,
        case_insensitive: bool = True,
    ) -> None:
        if interval <= 0:
            interval = 0.1
        self.repo = repo
        self.reader = reader
        self.interval = float(interval)
        self.case_insensitive = bool(case_insensitive)
        self._last_seen_key: Optional[str] = None
        self._stop_event = threading.Event()
        self._thread: Optional[threading.Thread] = None

    def _key(self, text: str) -> str:
        return text.casefold() if self.case_insensitive else text

    def run_step(self) -> Optional[dict]:
        """
        Perform a single poll step. Returns the added/touched row dict if new content is processed,
        otherwise None.
        """
        try:
            text = self.reader()
        except Exception:
            return None
        if not isinstance(text, str) or text == "":
            return None
        k = self._key(text)
        if self._last_seen_key is not None and k == self._last_seen_key:
            return None
        row = self.repo.add_text(text)
        self._last_seen_key = k
        return row

    def _loop(self) -> None:
        while not self._stop_event.is_set():
            try:
                self.run_step()
            except Exception:
                # Never break loop on step errors
                pass
            # Use wait for better responsiveness to stop
            self._stop_event.wait(self.interval)

    def start(self) -> bool:
        if self._thread and self._thread.is_alive():
            return False
        self._stop_event.clear()
        t = threading.Thread(target=self._loop, name="ClipboardMonitor", daemon=True)
        self._thread = t
        t.start()
        return True

    def stop(self, timeout: Optional[float] = 1.0) -> None:
        self._stop_event.set()
        t = self._thread
        if t and t.is_alive():
            try:
                t.join(timeout=timeout)
            except Exception:
                pass

    def is_running(self) -> bool:
        t = self._thread
        return bool(t and t.is_alive())